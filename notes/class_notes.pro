% На пролог променливите не се декларират предварително.  Дали
% дадена дума е променлива или символ за индивидна константа,
% пролог разпознава по следния начин: променливите започват с
% главна буква, а константите – с малка.  Например X, Y0,
% Резултат са променливи, а x, n5 и софия са константи.

% Забележка: в литературата за пролог такива константи се наричат
% атоми.  Тук обаче няма да ги наричаме атоми, за да не би някой
% да си помисли, че има нещо общо между атом и атомарна формула.

% Клауза от вида
%    p(X) :- q(X,Y), r(Z).
% отговаря на следната логическа формула:
%    q(x,y) & r(z) ⇒ p(z)
% Но понеже пролог ще приеме, че тази клауза е тъждествено вярна,
% то всъщност имаме следната формула:
%    ∀x∀y(q(x,y) & r(z) ⇒ p(z))

% Пролог „приема“, че сме му казали истината, цялата истина и
% само истината.  Затова ако кажем например следните две клаузи
%    p(X) :- q(X).
%    p(X) :- r(X).
% и няма други клаузи, в които се говори кога е верен предикатът
% p, то пролог ще реши, че е вярно
%    ∀x(q(x) ∨ r(x) ⇔ p(x))
% въпреки че ние сме му казали не това, а само
%    ∀x(q(x) ∨ r(x) ⇒ p(x))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ФУНКЦИОНАЛЕН СТИЛ НА ПРОГРАМИРАНЕ НА ПРОЛОГ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% При фунционалните езици дефинираме функция f, за която
%       f(x,y)=z, където y е някакъв израз.
% Вместо това на пролог ще дефинираме предикат p, такъв че
%       p(x,y,z) е истина тогава и само тогава, когато f(x,y)=z

% За момента да считаме (макар че не е точно така), че на пролог
% има един тип данни: термове, т.е. изрази.  Например = е
% равенство между изрази, а не равенство между числа.  Затова

%% ?- 1+2=3.
%% false.

%% ?- 1+2=1+X.
%% X = 2.

% Едно уникално и забележително от теоретична гледна точка
% свойство на пролог е това, че дори да го лишим от абсолютно
% всички вградени предикати, езикът продължава да бъде
% използваем.  Например естествените числа може да ги представим
% по следния начин:
%
%   - нулата ще представяме посредством символа 0 (разбира се тук
%     0 е символ за индивидна константа, а не число)
%   - числото n+1 ще представяме с терма s(n).
%
% Например числото 3 ще представяме посредством терма s(s(s(0)).
%
% След като сме избрали представяне на естествените числа
% посредством термове, не е проблем да дефинираме предикати за
% различните аритметични операции.  Например събирането може да
% дефинираме така:

% сбор(N,M,K) - К е сбор на естествените числа N и M

сбор(0,X,X).
сбор(s(X),Y,s(Z)) :- сбор(X,Y,Z).

%% ?- сбор(s(s(0)), s(s(s(s(0)))), Сбор).
%% Сбор = s(s(s(s(s(s(0)))))).

% Да дефинираме предикат за символно диференциране.  Засега да
% считаме, че типът данни, с които работи пролог, е типът „терм“.
% Разбира се аритметичните изрази са термове от специален вид,
% така че можем да работим с тях директно без да се налага да
% дефинираме собствени типове.

% dx(F,DF) - DF е производна на F по x (F е израз на реална
%            функция)

dx(0, 0).
dx(1, 0).
dx(2, 0).
dx(3, 0).
dx(4, 0).

% dx(X, 1) би казало, че производната на всяка функция е 1.
% Имаме нужда от нещо, което за нас е променлива, но за пролог не
% е.  Затова използваме x вместо X
dx(x, 1).
dx(y, 0).
dx(z, 0).
dx(t, 0).
dx(u, 0).
dx(v, 0).
dx(w, 0).
dx(-F, -DF) :- dx(F,DF).
dx(F+G, DF+DG) :- dx(F, DF), dx(G,DG).
dx(F-G, DF-DG) :- dx(F, DF), dx(G,DG).
dx(F*G, DF*G+DG*F) :- dx(F, DF), dx(G,DG).
dx(F/G, (DF*G-DG*F)/(G*G)) :- dx(F, DF), dx(G,DG).

dx(ln(F), DF/F) :- dx(F, DF).
dx(sin(F), cos(F)*DF) :- dx(F,DF).
dx(cos(F), -sin(F)*DF) :- dx(F,DF).

% Да пробваме как работи така дефинираният предикат:

%% ?- dx(x+y+z+1+t+0, F).
%% F = 1+0+0+0+0+0.

%% ?- dx(x+cos(x+y)*z-1/t+0, F).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0.

% Получихме верни отговори, но изразите са сложни и очевидно има
% начин да се опростят.  Да дефинираме предикат за опростяване на
% израз.

% Най-напред да даучим пролог на някои формули за опростяване на
% изрази.

формула(0+F, F).
формула(F+0, F).
формула(0-F, -F).
формула(F-0, F).
формула(0*_F, 0).
формула(_F*0, 0).
формула(0/_F, 0).
формула(1*F, F).
формула(F*1, F).
формула(F/1, F).
формула(sin(0), 0).
формула(F+(G+H), (F+G)+H).
формула(F*(G*H), (F*G)*H).
формула(F*2, 2*F).
формула(F*3, 3*F).
формула(F*4, 4*F).
формула(X+(-Y), X-Y).
формула((-X)-Y, -(X+Y)).
формула((-X)*Y, -(X*Y)).
формула(X*(-Y), -(X*Y)).
формула((-X)/Y, -(X/Y)).
формула(X/(-Y), -(X/Y)).
формула(-(-X), X).

% Предикатът редукция(F, G) опростява еднокретно израза F,
% прилагайки някоя от формулите за опростяване. Резултатът е G.

% Tук прилагаме предиката формула към целия израз F.
% Например (x+y)+0 ще се опрости до x+y.
редукция(F, F1) :- формула(F, F1).

% По-долу прилагаме предиката формула в дълбочина.  Например
% (x+0)+y ще се опрости до x+y.  По една клауза за всяка унарна
% операция и по две клаузи за всяка бинарна операция.

редукция(F+G, F1+G) :- редукция(F, F1).
редукция(G+F, G+F1) :- редукция(F, F1).
редукция(F-G, F1-G) :- редукция(F, F1).
редукция(G-F, G-F1) :- редукция(F, F1).
редукция(F*G, F1*G) :- редукция(F, F1).
редукция(G*F, G*F1) :- редукция(F, F1).
редукция(F/G, F1/G) :- редукция(F, F1).
редукция(G/F, G/F1) :- редукция(F, F1).
редукция(-F, -F1) :- редукция(F, F1).
редукция(ln(F), ln(F1)) :- редукция(F, F1).
редукция(sin(F), sin(F1)) :- редукция(F, F1).
редукция(cos(F), cos(F1)) :- редукция(F, F1).

% Да забележим, че чрез предиката редукция дефинираме многозначна
% функция, защото за един израз може да има много начини, по
% които той може да бъде опростен.  Например изразът x+0+y+0+x+0
% може да бъде опростен едностъпково по три различни начина:

%% ?- редукция(x+0+y+0+x+0, F).
%% F = x+0+y+0+x ;
%% F = x+0+y+x+0 ;
%% F = x+y+0+x+0 ;
%% false.

% Една многозначна функция може да има и нула на брой стойности.
% Тъй като нямаме формула, която да казва, че 1+1 е равно на 2,
% то изразът 1+1 няма да може да се опрости:

%% ?- редукция(1+1, F).
%% false.

% „Условен оператор“ на пролог:

% ( F -> G ; H) :- if F then G else H.

% Този „предикат“ може да се използва само когато програмираме
% функционално.  Когато програмираме логически, е възможно
% стойността на F все още да не бъде известна и затова условният
% оператор няма да работи коректно.  Един лош дефект на пролог е
% това, че компилаторът няма да ни предупреди, че се е случила
% грешка (въпреки че при правилно направен компилатор, това е
% възможно).  Вместо да се получи съобщение за грешка, просто
% програмата ще работи неправилно.  Този дефект се дължи на
% старостта на езика и се проявява не само тук, но и в други
% ситуации.

% Прилагаме едностъпково_опростяване докато може.
опростяване(F, G) :-
    (  редукция(F, F1)
    -> опростяване(F1, G)
    ;  G = F ).

% Този предикат прави едностъпкови опростявания на израза докато
% може, а не само веднъж.  Например в израза x+0+y+0+x+0 ще махне
% не една, а всички нули:

%% ?- опростяване(x+0+y+0+x+0, F).
%% F = x+y+x.

% Да видим как ще се опростят производните, които по-горе
% сметнахме:

%% ?- dx(x+y+z+1+t+0, F), опростяване(F, G).
%% F = 1+0+0+0+0+0,
%% G = 1.

%% ?- dx(x+cos(x+y)*z-1/t+0, F), опростяване(F, G).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0,
%% G = 1-sin(x+y)*z- - 0.

% Опрости се, но може и още.  Не сме казали на компютъра, че
% X-(-Y)=X+Y.  Ако добавим следния ред

%% формула(X-(-Y), X+Y).

% компютърът ще работи така:

%% ?- dx(x+cos(x+y)*z-1/t+0, F), опростяване(F, G).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0,
%% G = 1-sin(x+y)*z.


%%%%%%%%%%%%%%%%%
% СПИСЪЦИ
%%%%%%%%%%%%%%%%%

% Понеже на пролог работим с изрази, то на теория няма нужда от
% списъци.  Може да си мислим, че f(1,f(2,f(3,c))) е списъкът
% [1,2,3], а c е списъкът [].

% В израза f(X,Y) X е първият елемент и се нарича глава на
% списъка; Y е опашката - списък от останалите елементи

% Въпреки че на теория няма нужда от списъци, езикът пролог
% поддържа по-четлив синтаксис:

% вместо f(X,Y) пишем [X|Y]
% вместо f(1,f(2,f(3,c))) пишем [1,2,3]
% вместо c пишем []

% Примери:

%% ?- [A|X] = [1,2,3,4].
%% A = 1,
%% X = [2, 3, 4].

%% ?- [A,B|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% Y = [3, 4].

%% ?- [A,B,C,D|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% C = 3,
%% D = 4,
%% Y = [].

%% ?- [A,B,C,D,E|Y] = [1,2,3,4].
%% false.

% Ще спазвам следната уговорка:

% за списъци: X, Y, Z
% за елементи: A, B, C
% списък от списъци: XX, YY, ZZ

% СТРУКТУРНА ИНДУКЦИЯ (РЕКУРСИЯ) ЗА СПИСЪЦИ:

% разглеждаме два случая: [] и [A|X]

% Да дефинираме със структурна индукция предикат
% четно_позиционирани:

% четно_позиционирани(X, Y) - Y е списък от елементите на четна
%                             позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или
%          дължината на Y
четно_позиционирани([], []).
четно_позиционирани([_|X], Y) :- нечетно_позиционирани(X, Y).

% нечетно_позиционирани(X, Y) - Y е списък от елементите на
%                               нечетна позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или
%          дължината на Y
нечетно_позиционирани([], []).
нечетно_позиционирани([A|X], [A|Y]) :- четно_позиционирани(X, Y).

% Няма проблем да използваме тези предикати „функционално“:

%% ?- четно_позиционирани([1,2,3,4,5,6,7], X).
%% X = [2, 4, 6].

%% ?- нечетно_позиционирани([1,2,3,4,5,6,7], X).
%% X = [1, 3, 5, 7].

% Но не бива да си мислим, че сме дефинирали две функции.  Не,
% направили сме друго: обяснили сме на компютъра какво означава
% даден списък да съдържа елементите на четна позиция от друг.  А
% това, че след такова обяснение компютърът може да смята
% функция, е само страничен ефект.  Всъщност компютърът може
% много повече:

%% ?- четно_позиционирани(X, [1,2,3,4]), нечетно_позиционирани(X, [a,b,c,d,e]).
%% X = [a, 1, b, 2, c, 3, d, 4, e].

% Пролог може да работи с непълна информация.  Не е проблем да
% уточним единствено кои са елементите на четна позиция, при
% което другите ще останат неизвестни:

%% ?- четно_позиционирани(X, [1,2,3,4]).
%% X = [_6610, 1, _6622, 2, _6634, 3, _6646, 4] ;
%% X = [_6610, 1, _6622, 2, _6634, 3, _6646, 4, _7320].

% При правилно използване на логическия стил на програмиране имаме две
% гаранции:

% 1. Ако казваме на компютъра верни неща, ще получаваме само верни отговори.

% 2. Ако компютърът каже, че няма (повече) отговори, значи наистина няма.

% По този начин много лесно получаваме частичната коректност на една
% логическа програма.  При другите езици един ред от програмата не може да
% се разглежда изолирано от останалите.  На пролог обаче един ред е едно
% нещо, което казваме на компютъра.  Верността на това нещо не зависи от
% верността на останалите неща.  Затова частичната коректност на програмата
% се получава много лесно.  Например във втория ред от програмата за
% четно_позиционирани сме казали на компютъра следното нещо:

% на пролог:

%    четно_позиционирани([_|X], Y) :- нечетно_позиционирани(X, Y).

% същото, но за хора:

%    Ако списъкът Y се състои от елементите на нечетна позиция в списък X,
%    то тогава списъкът Y се състои от елементите на четна позиция в кой да
%    е списък от вида [_|X].

% Верността на горното не зависи по никакъв начин от верността на останалите
% неща, които сме казали в програмата.  Т.е. при проверка на частичната
% коректност разсъждаваме „локално“ и е много по-лесно да се разсъждава.

% p(X,Y) :- Y се получава като разменим в X елементите на четна позиция с
%           елементите на нечетна позиция.

p(X,Y) :- четно_позиционирани(X,V),   % (1)
          нечетно_позиционирани(X,W), % (2)
          четно_позиционирани(Y,W),   % (3)
          нечетно_позиционирани(Y,V). % (4)

% Ако прочетем горното като математическо твърдение, забелязваме, че то е
% вярно.  Това ни дава частичната коректност на предиката p.

% За да получим пълна коректност, трябва да видим, че са изпълнени условията
% в спецификацията на предикатите, които използваме.  В нашия случай това са
% предикатите четно_позиционирани и нечетно_позиционирани.  Условията в
% тяхната спецификация казват, че поне един от аргументите им трябва да бъде
% с известна дължина.  Да видим кога ще бъдат изпълнени тези условия.

% (1): X или V трябва да бъдат списък с известна дължина.  Но V е
% променлива, която на това място се среща за пръв път, така че няма как да
% бъде с известна дължина.  Значи X трябва да бъде с известна дължина.  След
% изпълнението на (1) променливата V също ще стане с известна дължина.

% (2): Вече знаем, че X трябва да бъде с известна дължина.  Така че в този
% ред условието е изпълнено.  След изпълнението на (2) променливата W също
% става списък с известна дължина.

% (3): Условието е изпълнено, защото W вече е списък с известна дължина.
% След изпълнението на (3) променливата Y също става списък с известна
% дължина (ако дължината на W е n, то дължината на Y е 2n или 2n+1.

% (4): Условието е изпълнено, защото когато дойдем до този ред Y и V са
% списъци с известна дължина.

% Горните разсъждения показват, че за да работи p(X,Y), е достатъчно X да
% бъде списък с известна дължина.  Това е условието за коректност на
% предиката p.

% При следващия въпрос сме спазили това условие за p.  Затова компютърът
% намира верният отговор и правилно отговаря, че втори верен отговор няма:

%% ?- p([1,2,3,4],X).
%% X = [2, 1, 4, 3] ;
%% false.

% Обаче при следващото извикване не сме спазили условието за коректност на p.
% Дори в този случай компютърът няма да ни излъже (защото имаме частична
% коректност), само че след като намери верният отговор, компютърът ще
% продължи да търси други отговори без да може да се сети, че такива няма:

%% ?- p(X,[1,2,3,4]).
%% X = [2, 1, 4, 3] ;
%%   Action (h for help) ? a
%% abort
%% % Execution Aborted


% елемент(A, X) :- А е елемент на списъка X
% Вграден е като member(A, X)
%
% Условие: Известно е ограничение отгоре за дължината на X

% елемент(A, [B|X]) :- A = B ; елемент(A, X).

елемент(A, [A|_]).
елемент(A, [_|X]) :- елемент(A, X).

% Вярно ли е, че 5 е елемент на [1,2,3]?
%% ?- елемент(5, [1,2,3]).
%% false.

% Вярно ли е, че 2 е елемент на [1,2,3]?
%% ?- елемент(2, [1,2,3]).
%% true 

% Кои са елементите на [1,2,3]?
%% ?- елемент(B, [1,2,3]).
%% B = 1 ;
%% B = 2 ;
%% B = 3 ;
%% false.

% Кои са всички триелементни списъци, които съдържат а, б и в?
%% ?- X=[_,_,_], елемент(а, X), елемент(б, X), елемент(в, X).
%% X = [а, б, в] ;
%% X = [а, в, б] ;
%% X = [б, а, в] ;
%% X = [в, а, б] ;
%% X = [б, в, а] ;
%% X = [в, б, а] ;
%% false.


% конкат(X, Y, Z) - Z е конкатенация на списъците X и Y
% Вграден е като append(X, Y, Z)
%
% Условие: Известно е ограничение отгоре за дължината на X или дължината
%          на Z

% Правим структурна индукция по първия аргумент.
конкат([], Y, Y).
конкат([A|X], Y, [A|Z]) :- конкат(X, Y, Z).

% Каква е конкатенацията на [] и [a,b,c]?
%% ?- конкат([],[a,b,c],X).
%% X = [a, b, c].

% Каква е конкатенацията на [1,2] и [3,4,5]?
%% ?- конкат([1,2],[3,4,5],X).
%% X = [1, 2, 3, 4, 5].

% Кой списък, конкатениран с [1,2], дава [1,2,3,4,5]?
%% ?- конкат([1,2],X, [1,2,3,4,5]).
%% X = [3, 4, 5].

% Може и така, защото е изпълнено условието за пълна коректност – известен е
% броят на елементите на първия или третия аргумент (в случая на първия):
%% ?- конкат([1,2], X, Y).
%% Y = [1, 2|X].

% Обаче така не може.  Макар пролог вярно да генерира всички възможни
% отговори, те са безброй много, така че програмата най-вероятно ще
% зацикли.
%% ?- конкат(X, [1,2], Y).
%% X = [],
%% Y = [1, 2] ;
%% X = [_2688],
%% Y = [_2688, 1, 2] ;
%% X = [_2688, _3742],
%% Y = [_2688, _3742, 1, 2] ;
%% X = [_2688, _3742, _4796],
%% Y = [_2688, _3742, _4796, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850],
%% Y = [_2688, _3742, _4796, _5850, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850, _6904],
%% Y = [_2688, _3742, _4796, _5850, _6904, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850, _6904, _7958],
%% Y = [_2688, _3742, _4796, _5850, _6904, _7958, 1, 2] ;

% Как списъкът [1,2,3,4] може да се разцепи на два списъка X и Y?
%% ?- конкат(X, Y, [1,2,3,4]).
%% X = [],
%% Y = [1, 2, 3, 4] ;
%% X = [1],
%% Y = [2, 3, 4] ;
%% X = [1, 2],
%% Y = [3, 4] ;
%% X = [1, 2, 3],
%% Y = [4] ;
%% X = [1, 2, 3, 4],
%% Y = [] ;
%% false.

% Алтернативна, по-неефективна, но по-кратка дефиниция на предиката елемент.
% елемент(A, X) :- конкат(_, [A|_], X).

% предпоследен(X, A) - А е предпоследният елемент на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

предпоследен(X, A) :- конкат(_, [A,_], X).

%% ?- предпоследен([1,2,3,4,5], A).
%% A = 4 

% префикс(X, Y) - списъкът X е начало (префикс) на списъка Y
%
% Условие: известно е ограничение отгоре за дължината на X или на Y

префикс(X, Y) :- конкат(X, _, Y).

% Кои са префиксите на [a,b,c]?
%% ?- префикс(X, [a,b,c]).
%% X = [] ;
%% X = [a] ;
%% X = [a, b] ;
%% X = [a, b, c] ;
%% false.

% На кои списъци X е префикс?
%% ?- префикс([1,2,3], X).
%% X = [1, 2, 3|_5620].

% ротация(X, Y) - списъкът Y е ротация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

ротация(X, Y) :- конкат(X1, X2, X), конкат(X2, X1, Y).

% Генериране на музикалните ладове
%% ?- ротация([до,ре,ми,фа,сол,ла,си], X).
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски
%% X = [ре, ми, фа, сол, ла, си, до] ;    % дорийски
%% X = [ми, фа, сол, ла, си, до, ре] ;    % фригийски
%% X = [фа, сол, ла, си, до, ре, ми] ;    % лидийски
%% X = [сол, ла, си, до, ре, ми, фа] ;    % миксолидийски
%% X = [ла, си, до, ре, ми, фа, сол] ;    % еолийски
%% X = [си, до, ре, ми, фа, сол, ла] ;    % локрийски
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски
%% false.

% пермутация(X, Y) - списъкът Y е пермутация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

% Първи начин: структурна индукция по първия аргумент на предиката.

пермутация([], []).
пермутация([A|X], Z) :- пермутация(X, Y), вмък(A, Y, Z).

% вмък(A, X, Y) - Y може да се получи като вмъкнем A на произволна
%                 позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или дължината на Y

вмък(A, X, [A|X]).
вмък(A, [B|X], [B|Y]) :- вмък(A, X, Y).

% може и така (по-неефективно и с по-ограничително условие за пълна
% коректност, но по-кратко):
вмък2(A, X, Y) :- конкат(X1, X2, X), конкат(X1, [A|X2], Y).

%% ?- вмък('!', [1,2,3], X).
%% X = [!, 1, 2, 3] ;
%% X = [1, !, 2, 3] ;
%% X = [1, 2, !, 3] ;
%% X = [1, 2, 3, !] ;
%% false.

%% ?- пермутация([a,b,c], X).
%% X = [a, b, c] ;
%% X = [b, a, c] ;
%% X = [b, c, a] ;
%% X = [a, c, b] ;
%% X = [c, a, b] ;
%% X = [c, b, a] ;
%% false.

% Втори начин: структурна индукция по втория аргумент на предиката.

пермутация2([], []).
пермутация2(X , [A|Z]) :- измък(X, A, Y), пермутация2(Y, Z).

% За измък може пак да използваме структурна индукция
% измък([A|Y], A, Y).
% измък([B|X], A, [B|Z]) :- измък(X, A, Z).

% Но не е нужно, защото измък е обратното на вмък, а какво значи вмък вече
% сме обяснили на пролог.

измък(X, A, Y) :- вмък(A, Y, X).

%% ?- измък([1,2,2,3], A, X).
%% A = 1,
%% X = [2, 2, 3] ;
%% A = 2,
%% X = [1, 2, 3] ;
%% A = 2,
%% X = [1, 2, 3] ;
%% A = 3,
%% X = [1, 2, 2] ;
%% false.

%% ?- пермутация2([1,2,3],X).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [2, 3, 1] ;
%% X = [3, 1, 2] ;
%% X = [3, 2, 1] ;
%% false.

% Условието при предикатите пермутация и пермутация2 беше да е известна
% дължината на първия аргумент.  От математическа гледна точка обаче ако X е
% пермутация на Y, то Y е пермутация на X.  Т.е. не би трябвало да има
% значение дали е известен първия или втория аргумент.  Да направим
% предикат, който може да се използва и в двете посоки.

% равна_дължина(X, Y) - списъците X и Y са с равна дължина.
%
% Условие: известно е ограничение отгоре за дължината на поне един от
%          аргументите

равна_дължина([],[]).
равна_дължина([_|X],[_|Y]) :- равна_дължина(X, Y).

двупосочна_пермутация(X, Y) :- равна_дължина(X, Y),
                               пермутация2(X, Y). % или пермутация(X,Y)

%% ?- двупосочна_пермутация([1,2,3],X).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [2, 3, 1] ;
%% X = [3, 1, 2] ;
%% X = [3, 2, 1] ;
%% false.

%% ?- двупосочна_пермутация(X,[1,2,3]).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [3, 1, 2] ;
%% X = [2, 3, 1] ;
%% X = [3, 2, 1] ;
%% false.

%%%%%%%%%%%%%%%%%%%%%%%%%
% ЦЕЛОЧИСЛЕНА АРИТМЕТИКА
%%%%%%%%%%%%%%%%%%%%%%%%%

% Когато използваме суи пролог, за да заредим библиотеката за целочислена
% аритметика, добавяме към програмата следния ред:

:- use_module(library(clpfd)).

% Първоначално пролог е създаден като безтипов език.  Или по-точно като
% език, в който единственият тип данни е „терм“ (също както например на лисп
% и скийм единственият тип данни е „списък“).  С други думи на пролог
% дефинираме ербранова структура, чийто единствен носител е множеството от
% всички термове без променливи.

% Когато се използва библиотеката за целочислена аритметика (както и други
% подобни библиотеки), програмата на пролог вече дефинира не ербранова
% структура, а двусортна структура с два носителя.  Първият носител е
% множеството от термовете без променливи (който го имаме и без тази
% библиотека).  Вторият носител е множеството от целите числа.  С други думи
% вече имаме не един, а два примитивни типа: израз (т.е. терм) и цяло число.

% Въпреки че структурата на програмата става двусортна, пролог е проектиран
% като безтипов език, т.е. като език за едносортна структура.  Това води до
% някои неудобства.  Едно от тях е това, че типът на изразите в програмата
% се определя от името на предиката.  Например предикатът = е равенство
% между термове, следователно стойностите на изразите от двете страни на =
% са термове.  Аритметичният предикат за равенство е #=.  При него
% стойностите на изразите от двете страни на равенството са цели числа.
% Примери:

%% ?- 1 + 2 = K.
%% K = 1+2.

%% ?- 1 + 2 #= K.
%% K = 3.

%% ?- 1 + K #= 10.
%% K = 9.

%% ?- 1 + 3*K #= 10.
%% K = 3.

%% ?- 1 + 2*K #= 10.
%% false.

% Ето някои от предикатите в библиотеката за целочислена аритметика:

% X #= Y       X е равно на Y
% X #\= Y      X е различно от Y
% X #> Y       X е по-голямо от Y
% X #< Y       X е по-малко от Y
% X #>= Y      X е по-голямо или равно от Y
% X #=< Y      X е по-малко или равно от Y
% X #<= Y      грешка

% Да дефинираме предикат за дължина на списък.  Иска ни се да направим това
% по следния начин:

% дълж(X, N) - N е дължината на X
%
% Условие: ....

дълж([], 0).
дълж([_|X], N+1) :- дълж(X,N).

% За съжаление не можем да направим това, защото пролог не е проектиран да
% работи с многосортни структури.  В следствие на това няма как да кажем на
% пролог, че вторият аргумент на предиката дълж е цяло число, а не израз.
% Затова предикатът дълж ще работи по следния начин:

%% ?- дълж([a,a,a,a], N).
%% N = 0+1+1+1+1.

% Когато използваме целочислена аритметика, трябва да спазваме следното
% правило: във фактите, както и отляво на :- не бива да се използват
% аритметични изрази.  По този начин пролог „разбира“ кои неща са числа и
% кои изрази.

% Ето как можем да дефинираме предикат за намиране на дължината на списък:

%% дължина([], N) :- N #= 0.
%% дължина([_|X], N) :- дължина(X, N-1).

% Пример:

% ?- дължина([a,a,a,a], N).
% N = 4.

% Да изведем условие за пълна коректност на предиката дължина.  Първата
% клауза в горната дефиниция свежда към предиката за ограничение #=, така
% че не може да доведе до зацикляне и затова не ни интересува.  Във втората
% клауза първият аргумент при рекурсивното извикване си намалява броя на
% елементите.  Следователно условието за пълна коректност е да бъде
% известно ограничение отгоре за броя на елементите на първия аргумент.
% Горният предикат обаче не може да се използва, ако дължината на списъка е
% известна, но самият списък е неизвестен.  Със съвсем малка подсказка този
% дефект може да се поправи:

% дължина(X, N) - N е дължината на X
%
% Условие: Известно е ограничение отгоре за N или за дължината на X

дължина([], N) :- N #= 0.
дължина([_|X], N) :- N #>= 0, дължина(X, N-1).

% Тук ако е известен вторият аргумент при рекурсивното извикване той ще се
% намали с единица.  Затова ако подскажем на пролог, че дължната на един
% списък не може да бъде отрицателно число, рекурсията ще бъде крайна.

% Да попитаме кой списък е с дължина 4:

%% ?- дължина(X, 4).
%% X = [_5544482, _5544648, _5544814, _5544980] ;
%% false.

% Да попитаме кои списъци са с дължина по-малка от 4:

%% ?- N #< 4, дължина(X, N).
%% N = 0,
%% X = [] ;
%% N = 1,
%% X = [_5548588] ;
%% N = 2,
%% X = [_5548588, _5550320] ;
%% N = 3,
%% X = [_5548588, _5550320, _5552566] ;
%% false.

% Вярно ли е, че [1,2,3,4] е с четна дължина?

%% ?- дължина([1,2,3,4], 2*K).
%% K = 2.

% Вярно ли е, че [1,2,3,4] е с нечетна дължина?

%% ?- дължина([1,2,3,4], 2*K+1).
%% false.

% nth(X, N, A) - А e N-тият елемент на списъка X
%
% Условие: Известно е ограничение отгоре за дължината на X или за N

nth([A|_], N, A) :- N #= 1.
nth([_|X], N1, A) :- N1 #>= 1, N1 #= N + 1, nth(X, N, A).

% Забележително е колко слабо условие за пълна коректност има този
% предикат.  Може да намерим N-тият елемент на списък, където N е
% неизвестно:

%% ?- nth([a,b,c], N, A).
%% N = 1, A = a ;
%% N = 2, A = b ;
%% N = 3, A = c ;
%% false.

% Можем да намерим третият елемент на списък, който е неизвестен:

%% ?- nth(X, 3, A).
%% X = [_89462, _89474, A|_89564]

% сума(X, N) - N е сумата от елементите на X
%
% Условие: Известно е ограничение отгоре за броя на елементите на X

сума([], N) :- N #= 0.
сума([K|X], N) :- N #= M + K, сума(X, M).

% Разбира се не е проблем да сметнем сумата на списък с известни елементи:

%% ?- сума([1,3,5],Сума).
%% Сума = 9.

% По-интересно обаче е това, че съгласно условието за пълна коректност може
% да прилагаме този предикат и към списъци, чиито елементи са неизвестни.
% Достатъчно ще бъде, ако дължината на списъка е известна:

%% ?- дължина(X, 3), сума(X, 5).
%% X = [_18300, _18306, _18312],
%% _18336 + _18300 #= 5,
%% _18312 + _18306 #= _18336

% факториел(N, F) - N! = F
%
% Условие: известно е ограничение отгоре за N

факториел(N, F) :- N #= 0, F #= 1.
факториел(N1, F1) :- N1 #> 0, N1 #= N + 1, F1 #= N1 * F, факториел(N, F).

% Да изведем условието за коректност на този предикат.  Първата клауза не
% ни интересува, защото свежда към предикати за ограничение.  Във втората
% клауза при рекурсивното извикване първият аргумент става с единица
% по-малък.  Но тъй като има условие този аргумент да бъде положително
% число, то това не може да става до безкрайност.  Така получаваме условие
% за коректност да бъде известно ограничение отгоре за първият аргумент.

% Трудно е да се разбере защо, но този предикат може да се използва и в
% обратна посока:

%% ?- факториел(F,120).
%% F = 5 

% Може дори да попитаме кои числа имат факториел между 10^100 и 10^101:

%% ?- F #>= 10^100, F #=<10^101, факториел(N,F).
%% F = 119785716699698917960727837216890987364589381425464
%% 25857555362864628009582789845319680000000000000000,
%% N = 70 ;
%% false.

% Въпреки че не е ясно защо в този случай пролог работи, важното е, че
% имаме гаранция, че той не ни лъже.  Следователно 70 е единственото число,
% чийто факториел е между 10^100 и 10^101.

% Има важна разлика между „уравненията“ между термове и аритметичните
% уравнения.  При уравненията между термове има ефективен алгоритъм
% (алгоритъмът за унификация), който позволява на компютъра без много
% усилия да извлича решения на системата от уравнения.  При аритметичните
% уравнения такъв алгоритъм няма.  Ако кажем на компютъра някакво
% аритметично уравнения, той ще го запомни, ще види какви бързи следствия
% могат да се направят от него, но ако не му кажем изрично, компютърът няма
% сам да се опитва да намери конкретни решения на условията, които се знаят
% до момента.  Използваме предиката label([A1,A2,...An]), за да поискаме от
% компютъра да генерира конкретни стойности на A1,A2,...,An.  Примери:

%% ?- N #> 0, N #< 4.
%% N in 1..3.

%% ?- N #> 0, N #< 4, label([N]).
%% N = 1 ;
%% N = 2 ;
%% N = 3.

%% ?- A #> 0, B #> 0, A+B #<5.
%% A in 1..3,
%% A+B#=_80970,
%% B in 1..3,
%% _80970 in 2..4.

%% ?- A #> 0, B #> 0, A+B #<5, label([A,B]).
%% A = B, B = 1 ;
%% A = 1, B = 2 ;
%% A = 1, B = 3 ;
%% A = 2, B = 1 ;
%% A = B, B = 2 ;
%% A = 3, B = 1.

% Предикатът label може да се използва само тогава, когато е известна
% крайна област, в която компютърът може да търси решение:

%% ?- N #> 0, label([N]).
%% ERROR: Arguments are not sufficiently instantiated

% Когато търси решения, пролог не винаги ще пробва всички възможно елементи
% на крайната област.  Да попитаме например дали има цели числа X, Y и Z,
% които са между 1 и 10000 и са решение на диофантовото уравнение
% (X+1000)³ - 2*(Y+1000)³ = Z

%% ?- 1#=<X,1#=<Y,1#=<Z,X#=<10000,Y#=<10000,Z#=<10000,
%%    (X+1000)^3 - 2*(Y+1000)^3 #= Z, label([X,Y,Z]).
%% false.

% Да забележим, че за всяка променлива има 10000 възможни стойности.
% Следователно вариациите на (X,Y,Z) са 1000000000000.  Това е е повече,
% отколкото компютърът може да провери за разумно време.  Въпреки това
% пролог намира отговора сравнително бързо, защото се сеща, че не е нужно
% да проверява всички вариации.

% Два ненужни предиката, които позволяват по-кратък запис:

% A in P..Q е еквивалентно на A #>= P, А #=< Q.
% [A1,A2,A3] ins P..Q е еквивалентно на A1 in P..Q, A2 in P..Q, A3 in P..Q.

% Докато при предикатите #>= и #=< отляво и отдясно може да стоят
% аритметични изрази, от дясната страна на предикатите in и ins не може да
% се използват изрази, а само променливи или константи.  Например не може
% да пишем K in 10^2..10^3.


% Задача. Да се напише предикат ограничен_списък(N,X), който по дадено
% естествено число N генерира в X всички списъци, чиято дължина е по-малка
% или равна на N и чиито елементи са естествени числа, по-малки или равни
% на N.

% След като прочетем задачата, от него трябва да извлечем две неща:
% 1. логическа дефиниция за ограничен_списък и 2. условие, при което
% предикатът трябва да работи.  В случая това ни дава следната
% спецификация:

% ограничен_списък(N, X) - X е списък с дължина по-малка или равна на N,
%                          чиито елементи са естествени числа, по-малки или
%                          равни на N
%
% Условие: Известно е N.

% След като сме готови със спецификацията, можем да пристъпим и към самата
% дефиниция.  В случая тя се прави съвсем лесно с нещата, които вече знаем:

ограничен_списък(N, X) :- L #=< N, дължина(X, L), X ins 0..N, label(X).

%% ?- ограничен_списък(2,X).
%% X = [] ;
%% X = [0] ;
%% X = [1] ;
%% X = [2] ;
%% X = [0, 0] ;
%% X = [0, 1] ;
%% X = [0, 2] ;
%% X = [1, 0] ;
%% X = [1, 1] ;
%% X = [1, 2] ;
%% X = [2, 0] ;
%% X = [2, 1] ;
%% X = [2, 2] ;
%% false.

% Предикатът ins ни помогна да направим по-кратко решение, но всъщност може
% и без него:

ограничен_списък2(N, X) :- L #=< N, дължина(X, L), елементи_отдо(0, N, X),
			   label(X).

% елементи_отдо(N1, N2, X) :- елементите на X са цели числа между N1 и N2
%
% Условие: Известно е ограничение отгоре за дължината на X

% Най-естествено е да реализираме този предикат с квантор за всеобщност:

% елементи_отдо(N1, N2, X) :- ∀K(елемент(K,X) ⇒ N1 #=< K, K #=< N2)

% За съжаление кванторът за всеобщност все още няма пълноценна реализация
% на пролог.  Затова се налага да използваме рекурсивна дефиниция:

елементи_отдо(_, _, []).
елементи_отдо(N1, N2, [A|X]) :-
    A #>= N1, A #=< N2, елементи_отдо(N1, N2, X).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% БЕЗКРАЙНИ ГЕНЕРАТОРИ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Безкрайните генератори нямат практически приложения, но на изпита по ЛП
% те често се използват за задачи.

% Методите за доказателство на коректност, които използвахме досега, не
% могат да се прилагат за безкрайни генератори.  За да се напише правилна
% дефиниция на безкраен генератор, има два подхода:
%
% 1. Да знаем как работи пролог.  Този подход по-традиционен, но има два
%    недостатъка: използваме пролог не като логически език и обръщаме
%    голямо внимание на особености на пролог, които най-вероятно няма да са
%    в сила при бъдещите езици за логическо програмиране.
%
% 2. Да сведем дефинирането на безкраен генератор към нещата, което вече
%    знаем как се правят.  За щастие това не е трудно.

% Най-напред запомняме наизуст следната дефиниция на генератор на естествените числа:

nat(N) :- N #= 0 ; nat(N-1).

%% ?- nat(N).
%% N = 0 ;
%% N = 1 ;
%% N = 2 ;
%% N = 3 ;
%% N = 4 ;
%% ...

% Няма да изследваме защо тази дефиниция работи, ами просто приемаме това
% като факт.  След като вече имаме тази дефиниция, чрез нея можем да
% дефинираме кой да е безкраен генератор по следния начин:

% безкраен_генератор(X) :- nat(N), краен_генератор(N, X).

% Тук краен_генератор(N, X) трябва да има следните свойства:
%
% 1. За всяко N има краен брой X, за които краен_генератор(N, X) е истина;
%
% 2. безкраен_генератор(X) е истина тогава и само тогава, когато за някое
%    естествено число N е истина краен_генератор(N, X).

% Пример 1.  Да се дефинира генератор на двойките [A,B] от естествени числа.

% Ето един неправилен, но често срещащ се на изпита начин:
%
% двойка естествени([A,B]) :- nat(A), nat(B).

% Горната дефиниция няма вида
%
%     безкраен_генератор(X) :- nat(N), краен_генератор(N, X).
%
% защото nat(B) не е краен генератор.  Ето един правилен начин:

двойка_естествени([A,B]) :- nat(N), A in 0..N, B in 0..N, label([A,B]).

% Горната дефиниция е правилна, защото
%
% 1. За всяко N има краен брой двойки [A,B], за които A in 0..N и B in 0..N
%
% 2. [A,B] е двойка от естествени числа тогава и само тогава, когато за
%    някое естествено число N е вярно A in 0..N и B in 0..N.

% Пример 2. Да се дефинира генератор на всички списъци от естествени числа.

списък_естествени(X) :- nat(N), L #=< N, дължина(X, L), X ins 0..N,
			label(X).

% Горната дефиниция е правилна, защото
%
% 1. За всяко N има краен брой X, които са списъци с дължина, по-малка или
%    равна на N и чиито елементи са от 0 до N
%
% 2. X е списък от естествени числа тогава и само тогава, когато съществува
%    такова естествено число N, че X е списък с дължина, по-малка или равна
%    на N и елементите му са от 0 до N.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% НЯКОИ ВЪЗМОЖНОСТИ НА ПРОЛОГ, КОИТО НИ ПОЗВОЛЯВАТ ДА ПИШЕМ КРАТКИ ПРОГРАМИ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Тук ще разгледаме някои опасни възможности на пролог.  Те помагат да
% правим много кратки програми, но използването им е рисковано.  Ако
% използваме тези възможности неправилно, компютърът вместо да даде
% съобщение за грешка може да даде грешен отговор.


% ОТРИЦАНИЕ
% ---------

% Официален синтаксис: \+ p(X)
% Синтаксис, който тук ще бъде използвам: not(p(X))

% Отрицанието има следната особеност.  Да допуснем, че компютърът стига до
% not(p(X,Y)).  Нека тук X символизира всички неща, чиято стойност в този
% момент е известна, a Y – нещата, чиято стойност все още не е известна.
% Тогава смисълът на
%
%      not(p(X,Y))
%
% ще бъде
%
%     ¬∃Y p(X,Y)
%
% или, което е все едно:
%
%     ∀Y ¬p(X,Y)

% Да забележим, че неизвестните неща Y стават локални променливи, така че
% отрицанието не може да се използва като генератор, а само за проверка
% дали нещо вече известно няма определено свойство.

% Когато в целта на отрицанието се използват аритметични предикати, след
% изпълнението на целта не бива да остават променливи, които все още не са
% получили стойност.  За да подсигурим, че това няма да се случи, може в
% края на целта да използваме label.

% Примери:

% Тук питаме кои числа N между 0 и 10 не могат да се представят като сума
% на два квадрата на числа между 0 и 10:

%% ?- 0 #=< N, N #=< 10, label([N]),
%%    not((0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%         N #= A^2+B^2, label([A,B]))).

% Тук питаме вярно ли е, че за всеки N, A и B от 0 до 10 числото N няма да
% бъде сума на квадратите на A и B:

% По-добре е обаче горният въпрос да бъде зададен по следния начин:

%% ?- not((0 #=< N, N #=< 10, 0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%         N #= A^2+B^2, label([A,B,N]))).

% Тук питаме какви трябва да бъдат N, A и B, така че да бъдат числа от 0 до
% 10 и N да не бъде сума от квадратите на A и B:

%% ?- 0 #=< N, N #=< 10, 0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%    N #\= A^2+B^2, label([A,B,N]).

% Да дефинираме на един ред предикат, който проверява дали дадено число е
% просто.

% просто(P) - P е просто число
%
% Условие: известно е P

просто(P) :- P #>= 2, not((K #>= 2, K #< P, P #= K * M, label([K, M]))).

% УНИВЕРСАЛЕН КВАНТОР С ИМПЛИКАЦИЯ
% --------------------------------

% Синтаксис: forall(p(X), q(X)).

% Да допуснем, че компютърът стига до forall(p(X,Y), q(X,Y,Z)).  Нека тук X
% символизира всички неща, чиято стойност в този момент е известна, а Y са
% нещата в p(X,Y), чиято стойност все още не е известна.  Нека Z са неща,
% чиято стойност не става известна дори след изпълнението на p(X,Y).
% Тогава смисълът на
%
%      forall(p(X,Y), q(X,Y,Z))
%
% ще бъде
%
%      ∀Y(p(X,Y) ⇒ ∃Z q(X,Y,Z))

% Да забележим, че също както при отрицанието, и тук неизвестните неща
% получават квантори.  Затова предикатът forall не може да се използва като
% генератор, а само за проверка дали нещо, вече известно, има определени
% свойства.

% След изпълнението на p(X,Y) стойността на Y трябва да стане напълно
% известна.  След изпълнението на q(X,Y,Z) всички аритметични променливи от
% Z трябва да получат стойност.  За да подсигурим последното, може в края
% на q(X,Y,Z) да използваме label.

% Примери:

% Вярно ли е, че всички елементи на [2,4,6,-7] са положителни?
%% ?- forall(елемент(A, [2,4,6,-7]), A #> 0).
%% false.

% Вярно ли е, че всички елементи на [2,4,6,-8] са четни?
%% ?- forall(елемент(A, [2,4,6,-8]), A #= 2*K).
%% true.

% Да забележим, че в момента, в който пролог изпълнява A #= 2*K,
% променливата A вече има конкретна стойност и значи K също ще получи
% конкретна стойност.  Затова е изпълнено изискването на forall да не се
% оставят аритметични променливи с неуточнена стойност.  Но ако не сме
% сигурни, може да се „подсигурим“ по следния начин:

%% ?- forall(елемент(A, [2,4,6,-8]), (A #= 2*K, label([K]))).

% Пример 1.  Да се дефинира предикат r(X,Y), който по дадени списъци X и Y
% проверява дали всеки елемент на X, който е четно число, е елемент на Y.

% r(X, Y) - всеки елемент на X, който е четно число е елемент на Y
%
% Условие: X и Y са известни списъци

r(X, Y) :- forall( (елемент(A, X), A #= 2*B, label([B])),
		   елемент(A, Y) ).

% Ще дефинираме предикат за „подмножество“ по два начина: с импликация и с
% рекурсия.  Най-напред с импликация.

% подмножество1(X, Y) - елементите на X са елементи на Y
%
% Условие: X и Y са известни списъци
подмножество1(X, Y) :- forall( елемент(A, X), елемент(A, Y) ).

% подмножество2(X, Y) - елементите на X са елементи на Y
%
% Условие: известно е ограничение отгоре за броя на елементите на X и на Y

подмножество2([], _).
подмножество2([A|X], Y) :- елемент(A, Y), подмножество2(X, Y).

% Да забележим, че първата дефиниция е по-кратка, но има много
% по-ограничително условие: може да се използва само за проверка.  Втората
% дефиниция може да бъде прилагана и към списъци, чиито елементи все още не
% са известни.

%% ?- подмножество1([1,3],[1,2,3]).
%% true.

%% ?- подмножество1([1,7],[1,2,3]).
%% false.

% Кои списъци с дължина по-малка или равна на 2 са подмножества на [1,2,3]:

%% ?- N #=< 2, дължина(X, N), подмножество2(X, [1,2,3]).
%% N = 0, X = [] ;
%% N = 1, X = [1] ;
%% N = 1, X = [2] ;
%% N = 1, X = [3] ;
%% N = 2, X = [1, 1] ;
%% N = 2, X = [1, 2] ;
%% N = 2, X = [1, 3] ;
%% N = 2, X = [2, 1] ;
%% N = 2, X = [2, 2] ;
%% N = 2, X = [2, 3] ;
%% N = 2, X = [3, 1] ;
%% N = 2, X = [3, 2] ;
%% N = 2, X = [3, 3] ;
%% false.

% Ако вместо подмножество2 използваме подмножество1 компютърът ще ни
% излъже, че всички списъци с дължина 0, 1 или 2 са подмножества на
% [1,2,3], защото не е спазено по-ограничителното условие за коректност:

%% ?- N #=< 2, дължина(X, N), подмножество1(X, [1,2,3]).
%% N = 0, X = [] ;
%% N = 1, X = [_] ;
%% N = 2, X = [_, _] ;
%% false.


% СПИСЪК ОТ ВСИЧКИ РЕШЕНИЯ
% ------------------------

% findall(A, P, X) е приблизително същото като X = {A: P}
%                    т.е. X става списък от всички A, за които P е вярно.

% Изискванията за използване на findall подобни на тези на not и forall.
% На всички неща в P, които не се срещат в A и при извикването на findall
% все още не са получили стойност, ще бъде сложен квантор ∃.  След
% изпълнението на P всички променливи в P и A (не само аритметичните)
% трябва да са получили конкретни стойности.

% Пример:

% X е списък от четните елементи на [1,3,4,2,9,22]:
%% ?- findall(A,
%%            (елемент(A,[1,3,4,2,9,22]), A #= 2*K),
%%            X).
%% X = [4, 2, 22].

% Да забележим, че горе при изпълнението на A #= 2*K променливата A вече
% има конкретна стойност и значи K също ще получи конкретна стойност.  По
% този начин всички променливи получават стойност, което е изискване на
% findall. Ако не сме сигурни за този тип неща, е по-добре да се подсигурим
% с label:

%% ?- findall(A,
%%            (елемент(A,[1,3,4,2,9,22]), A #= 2*K, label([K])),
%%            X).


% Да получим списък от простите числа между 0 и 1000:

%% ?- findall(P, (P in 0..1000, label([P]), просто(P)), X).
%% X = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
%% 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,
%% 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,
%% 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,
%% 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
%% 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,
%% 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
%% 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,
%% 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
%% 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
%% 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997].


% Задача.  Да се дефинира предикат ppp(X), който по даден списък от списъци
% X проверява дали сумата на елементите на четна позиция във всеки елемент
% на X, съдържащ просто число, e предпоследен елемент на елемент на X

% Най-напред от условието на задачата извличаме спецификацията на предиката:

% ppp(X) - сумата на елементите на четна позиция във всеки елемент на X,
%          съдържащ просто число, e предпоследен елемент на елемент на X
%
% Условие: X е известен списък

% Най-напред нека да изкажем условието на задачата по по-логически начин:

% Да се дефинира предикат ppp(X), който по даден списък от списъци
% X проверява дали е изпълнено следното свойство:
%
% за всяко Y ако
%      Y∈X и
%      ∃A(A∈Y и просто(А)) и
%      S е сумата на елементите на четна позиция в Y,
% то съществува Z, такова че
%      Z∈X и
%      S е предпоследен елемент на Z

ppp(X) :-
    forall( ( елемент(Y, X),
	      елемент(A, Y), просто(A),
	      findall(B, (nth(Y, N, B), N #= 2*_), Y2), сума(Y2, S) ),
	    ( елемент(Z, X),
	      конкат(_, [S, _], Z) ) ).

% Задача.  Да се дефинира предикат pppp(X), който по даден списък X от
% списъци от числа проверява дали всеки предпоследен елемент на елемент на
% четна позиция е просто число.

% Отново най-напред от условието на задачата извличаме спецификацията:

% pppp(X) - всеки предпоследен елемент на елемент на четна позиция в X е
%           просто число
%
% Условие: Известен е X.

pppp(X) :-
    % Тук X е известно, а за всички останали променливи има локални
    % квантори.
    forall(( % ∀K ∀A                            % за всеки K и A
             nth(X, 2*_K, A),                   % ако A е 2.К-тия елем. на X
             съединение(_, [Предпоследен,_], A) % и Предпоследен е предпо-
           ),                                   %   следният елем. на A
           просто(Предпоследен)).               % то Предпоследен e просто


% СОРТИРОВКА

% В книгите и Интернет може да се намерят различни начини за сортировка на
% пролог.  Тези начини общо взето са същите, които може да се използват и
% при програмиране с функционален език.  Затова тук няма да ги показваме.
% Вместо това ще видим един начин за сортировка, който е неефективен и
% затова на практика неприложим, но за сметка на това е много кратък.
% Последното прави този начин за сортировка идеален за изпита.

% Започваме с математическата дефиниция на X

% сорт(X, Y) - Y е пермутация на X, която е сортирана
%
% Условие: X е известен числов списък.

% Един списък е сортиран, ако за всеки два негови съседни елементи A и B е
% вярно A ≦ B.  На пролог можем да кажем, че A и B са съседни елементи на
% даден списък, например [1,2,3,4,5,6], по следния начин:

%% ?- конкат(_, [A,B|_], [1,2,3,4,5,6]).
%% A = 1, B = 2 ;
%% A = 2, B = 3 ;
%% A = 3, B = 4 ;
%% A = 4, B = 5 ;
%% A = 5, B = 6 ;
%% false.

% Сега вече сме готови да преведем директно на пролог математическата
% дефиниция на предиката сорт:

сорт(X, Y) :- пермутация(X, Y), forall(конкат(_, [A,B|_], Y), A #=< B).

%% ?- сорт([1,6,2,3,8,4], X).
%% X = [1,2,3,4,6,8]


% Първа задача от писмения изпит по ЛП, януари 2023
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Списък от естествени числа [a_1, a_2,..., a_3n] ще наричаме
% специфичен, ако за всяко естествено число k ∈ {1,...,n} е изпълнено:
% 
%        ⎧ a_(a_k + 6),   ако 1 ≦ a_k + 6 ≦ 3n и 1 ≦ a_k ≦ k
% a_3k = ⎨
%        ⎩ 3a_(3n−k) + 1, иначе
%
% Да се дефинира предикат s(X), който при преудовлетворяване генерира в X
% всички специфични списъци.

% Най-напред ще направим кратко решение „като за изпит“.  След това ще
% видим едно незначително по-дълго, но много по-ефективно решение.

% Краткото решение има следната структура:
%
% s1(X) :- генерираме_произволен_списък(X),
%          проверяваме_че_е_специфичен(X).

s1(X) :- nat(N), Дълж #=< N, дължина(X, Дълж), X ins 0..N, label(X),
	 специфичен(X).

% специфичен(X) - X е специфичен
%
% Условие: X е известен списък

специфичен(X) :- 
    дължина(X, 3*N), 
    forall( ( K in 1..N, label([K]) ),
	    ( nth(X, K, Ak),
	      nth(X, 3*K, A3k),
	      (  1 #=< Ak+6, Ak+6 #=< 3*N, 1 #=< Ak, Ak #=< K
	      -> nth(X, Ak+6, A3k)
	      ;  A3k #= 3*A3nk+1, nth(X, 3*N-K, A3nk) ) ) ).

% Проверка:

%% ?- s1(X).
%% X = [] ;
%% X = [] ;
%% X = [] ;
%% X = [] ;
%% X = [0, 0, 1] ;
%% X = [1, 0, 1] ;
%% X = [2, 0, 1] ;
%% X = [3, 0, 1] ;
%% X = [] ;
%% X = [0, 0, 1] ;
%% X = [0, 1, 4] ;
%% X = [1, 0, 1] ;
%% ...

% При търсене на 6-елементни специфични списъци се усеща леко забавяне:

%% ?- X=[_,_,_,_,_,_], s1(X).
%% X = [0, 0, 1, 0, 0, 1] ;
%% X = [0, 0, 1, 1, 0, 4] ;
%% X = [0, 0, 4, 0, 1, 1] ;
%% X = [0, 0, 4, 1, 1, 4] ;
%% ...

% При търсене на 9-елементни специфични списъци компютърът все още може да
% намери отговори, но доста бавно:

%% ?- X=[_,_,_,_,_,_,_,_,_], s1(X).
%% X = [0, 0, 1, 0, 0, 1, 0, 0, 0] ;
%% X = [0, 0, 1, 0, 0, 4, 1, 0, 1] ;
%% X = [0, 0, 1, 0, 0, 7, 2, 0, 2] ;
%% ...

% Горният предикат не е в състояние да намери 12-елементни специфични
% списъци за разумно време.

% Причината за бавната работа на предиката е следната: има твърде много
% произволни списъци от естествени числа и само една малка част от тях са
% специфични.

% За да избегнем (а по-точно отложим) този комбинаторен взрив, ще се
% възползваме от възможността на пролог да работи с неизвестни числа.
% Преди още да генерираме конкретни стойности на елементите на списъка, ще
% кажем на компютъра формулите, които са верни за един специфичен списък.
% По този начин ще трябва да се генерират много по-малко списъци.

% С други думи, горното решение, което има следния вид

% s(X) :- nat(N), 
%         дължината на X е ≦ N, елементите на X са 0..N,
%         label(X),
%         специфичен(X).

% ще преобразуваме в ето този вид:

% s(X) :- nat(N), 
%         дължината на X е ≦ N, елементите на X са 0..N,
%         специфичен(X),
%         label(X).

% Ще се наложи обаче да дадем друга дефиниция на предиката специфичен.
% Горната дефиниция не е подходяща, защото по две причини не може да се
% използва тогава, когато елементите на X са неизвестни:
%
% 1. forall може да се използва само за проверка дали неща, които вече са
%    известни имат дадено свойство.  В случая X трябва да бъде известен
%    списък.
%
% 2. „Функционалният“ условен оператор ( условие -> ако_да ; ако_не ) също
%    работи само ако в условието вече са известни всички неща.  Ако обаче
%    елементите на X са неизвестни, то и условието няма да бъде ясно дали е
%    истина или лъжа.
%
% Тези проблеми се решават по следния начин:
%
% 1. Вместо forall ще използваме рекурсивна дефиниция.
%
% 2. Вместо ( A -> B ; C ) ще използваме ((A, B) ; (¬A, C)).

s2(X) :- nat(N), Дълж #=< N, дължина(X, Дълж), X ins 0..N,
	 специфичен2(X), label(X).

% специфичен2(X) - X е специфичен
%
% Условие: X е списък с известна дължина

специфичен2(X) :- 
    дължина(X, 3*N), 
    частично_специфичен(X, N).

% частично_специфичен(X, M) - Нека 3n е дължината на X.  Тогава за всяко
%                             естествено число k ∈ {1,...,M} е изпълнено:
% 
%        ⎧ a_(a_k + 6),   ако 1 ≦ a_k + 6 ≦ 3n и 1 ≦ a_k ≦ k
% a_3k = ⎨
%        ⎩ 3a_(3n−k) + 1, иначе

частично_специфичен(_, K) :- K #= 0.
частично_специфичен(X, K) :- 
    K #> 0,
    дължина(X, 3*N), 
    nth(X, K, Ak),
    nth(X, 3*K, A3k),
    ( 1 #=< Ak+6, Ak+6 #=< 3*N, 1 #=< Ak, Ak #=< K,
      nth(X, Ak+6, A3k)
    ; ( 1 #> Ak+6 #\/ Ak+6 #> 3*N #\/ 1 #> Ak #\/ Ak #> K ),
      A3k #= 3*A3nk+1, nth(X, 3*N-K, A3nk) ),
    специфичен(X, K-1).

% Благодарение на това, че в дефиницията на s2 и помощните му предикати
% работим не с напълно генерирани списъци, а със списъци с неизвестни
% елементи, то s2 работи значително по-бързо от s1.  Предикатът s1 не е в
% състояние да генерира списъци с двуцифрена дължина.  Предикатът s2 е в
% състояние да генерира списъци дори с трицифрена дължина.

%%%%%%%%%%%%%%%%%%%%
% ГРАФИ
%%%%%%%%%%%%%%%%%%%%

% Въпреки че пролог не е обектноориентиран език, има начин да програмираме
% така, че да имитираме използването на абстрактен клас с наследници.
% Точно така искаме да постъпим, когато работим с графи, защото не
% съществува оптимална структура данни, представяща графите.  За някои
% задачи едно представяне е по-ефективно, за други друго.  Всички тези
% представяния ще бъдат различни наследници на абстрактния клас „граф“.  По
% този начин ако направим някой предикат да използва абстрактния клас
% „граф“, то този предикат ще бъде използваем независимо как представяме
% графа в паметта на компютъра.

% В „интерфейса“ на абстрактния клас „граф“ ще имаме само следните два
% предиката:

% връх(G, v) - v е връх в графа G
% ребро(G, u, v) - (u,v) е ребро в графа G

% Тъй като всеки „наследник“ на класа „граф“ ще има свои собствени
% дефиниции на връх и ребро, то пролог „ще се притесни“ и ще ни дава много
% предупреждения.  Въпреки предупрежденията, програмата е вярна, но
% най-добре да успокоим пролог със следните две подсказки:

:- discontiguous връх/2.
:- discontiguous ребро/3.

% Да дефинираме „наследник“ на този абстрактен клас, при който графът се
% представя по обичайния математически начин – като двойка (VV, EE), където
% VV е списък от върховете, a ЕЕ списък от ребрата.

връх((VV,_EE), V) :- елемент(V, VV).
ребро((_VV,EE), U, V) :- елемент((U,V), EE).

% С това приключи дефиницията на първия наследник на класа „граф“.  

% Много често в задачите на изпита по ЛП графите се представят посредством
% списък от двойки [u,v] – по една такава двойка за всяко ребро (u,v).
% Разбира се такова представяне може да се използва само за графи без
% изолирани върхове, защото по същество помним само ребрата, а изолираните
% върхове нямат ребра.

% При такова представяне на графа, предикатите връх и ребро може да се
% дефинират така:

връх(G, U) :- елемент([U,_], G) ; елемент([_,U], G).
ребро(G, U, V) :- елемент([U,V], G).

% Вече имаме и втори наследник на класа „граф“.  Важно е, че тези две
% представяния не се припокриват.  При първото графът е списък, при второто
% е наредена двойка.  Наредените двойки (VV,EE) не са списъци, нито
% списъците са наредени двойки, така че няма да има „интерференция“ между
% двете дефиниция на връх и ребро.

% Да дефинираме още едно представяне на графи, което често се оказва
% най-ефективно.  Графът G ще представяме посредством такъв списък, че за
% всеки връх U в списъка има единствен елемент от вида [U,V1,V2,...,Vn] и в
% графа има ребро (U,V) тогава и само тогава, когато V=Vi за някое i.

% Тъй като при предното представяне графът също бе списък, тук вместо
% списък X ще използваме терм от вида f(X).  Може да считаме, че f е името
% на класа наследник на класа „граф“.  Ако това бе по-реалистичен пример,
% то вместо f трябваше да използваме някакво по-разбираемо име.

връх(f(X), U) :- елемент([U|_], X).
ребро(f(X), U, V) :- елемент([U|VV], X), елемент(V, VV).

% Ще дефинираме още два „класа“, g1 и g2.  Всеки от тях отговаря на
% единствен граф, чиито върхове и ребра се задават посредством факти на
% пролог:

% Конкретни графи G1 и G2

връх(g1, a).  връх(g1, b).  връх(g1, c).  връх(g1, d).
връх(g1, e).  връх(g1, f).  връх(g1, g).  връх(g1, h).

ребро(g1, a, b).  ребро(g1, a, c).  ребро(g1, b, d).
ребро(g1, c, d).  ребро(g1, c, e).  ребро(g1, d, f).
ребро(g1, e, f).  ребро(g1, e, g).  ребро(g1, f, h).
ребро(g1, g, h).

връх(g2, a).  връх(g2, b).  връх(g2, c).  връх(g2, d).
връх(g2, e).  връх(g2, f).  връх(g2, g).  връх(g2, h).

ребро(g2, a, a).  ребро(g2, a, e).  ребро(g2, a, b).
ребро(g2, b, d).  ребро(g2, c, b).  ребро(g2, d, c).
ребро(g2, d, e).  ребро(g2, e, f).  ребро(g2, f, d).
ребро(g2, g, h).  ребро(g2, g, e).  ребро(g2, h, g).
ребро(g2, h, f).

% Често път се дефинира като редица от вида връх-ребро-връх-ребро-....  На
% други места път се дефинира просто като редица от ребра.

% Тук ще считаме, че път е такава непразна редица от върхове, че между
% всеки два съседни има ребро

% път(G, U, V, X) - X е път в G от връх U до връх V
%
% Условие: G е краен граф и (G е ацикличен или е известно ограничение
%          отгоре за дължината на пътя X)

път(G, V, V, [V]) :- връх(G, V).
път(G, V1, U, [V1,V2|X]) :- ребро(G, V1, V2), път(G, V2, U, [V2|X]).

% Тук поради извикването на връх(G,..) и ребро(G,..,..) се налага G да бъде
% краен граф (иначе може да генерираме безброй много върхове и ребра).
% Разбира се с представянията, които имаме до момента, може да се дефинират
% само крайни графи.  В момента обаче ние работим не с тези представяния, а
% с абстрактния клас „граф“, а той може да има наследник, позволяващ
% безкрайни графи.

% Ако графът е ацикличен, то рекурсията е крайна благодарение на втория
% аргумент.  Ако е известно ограничение отгоре за дължината на пътя, тогава
% помага четвъртият аргумент.

% Примери:

%% ?- път(g1, a, f, X).
%% X = [a, b, d, f] ;
%% X = [a, c, d, f] ;
%% X = [a, c, e, f] ;
%% false.

%% ?- път(g2, a, f, X).
%% ERROR: Stack limit (1.0Gb) exceeded

%% ?- N #=< 5, дължина(X, N), път(g2, a, f, X).
%% N = 3, X = [a, e, f] ;
%% N = 4, X = [a, a, e, f] ;
%% N = 5, X = [a, a, a, e, f] ;
%% N = 5, X = [a, b, d, e, f] ;
%% false.

% Да направим предикат, който може да се използва и тогава, когато графът е
% цикличен.  Да забележим, че в цикличен краен граф между два върха може да
% има безброй много пътища.  Затова предикат за генериране на всички пътища
% между два върха в цикличен граф, би се оказал безкраен генератор и значи
% няма как да бъде полезен.  Вместо това ще дефинираме предикат за
% генериране на прости пътища.  В краен граф простите пътища между два
% върха винаги са краен брой – дори тогава, когато графът е цикличен.

% За съжаление в теория на графите няма еднообразие на дефинициите.  Тук ще
% използваме следната дефиниция: прост път е път, в който няма повтарящи се
% върхове, с изключение на това, че позволяваме първият връх да съвпада с
% последния.

% Най-напред ще дадем дефиниция на предиката, която е неефективна, но
% съответства на горната математическа дефиниция, кратка е и значи е
% подходяща за изпит или контролно по ЛП.

% прост_път(G, U, V, X) - X е прост път в G от връх U до връх V
%
% Условие: G е краен граф

% Идея: дължината N на прост път е по-малка или равна от броя върхове на
% графа плюс едно.  След като ограничим по този начин дължината, може да
% използваме предиката път, за да генерираме пътя, и две отрицания, за да
% филтрираме пътищата, които не са прости пътища.

прост_път(G, U, V, X) :-
    N #=< Брой_върхове + 1,
    findall(W, връх(G, W), VV_), % VV_ е списък от върховете на графа
    sort(VV_, VV),               % VV е списък от върховете без повторения
    дължина(VV, Брой_върхове),   % Брой_върхове е броят върхове в графа
    дължина(X, N),               % N е дължината на пътя
    път(G, U, V, X),         % коректно, защото дължината е ограничена
    % В долните отрицания X вече има стойност.  Променливите A и Y са без
    % стойност, значи са локални и смисълът е на отрицанията е ¬∃A∃Y(.....)
    not(( конкат([_|_], [A|Y], X), % сред върховете от втория нататък няма
	  елемент(A, Y) )),        % повторения
    not(( конкат([A|Y], [_], X),   % първият връх не се среща на друго място
	  елемент(A, Y) )).        % преди последния връх

% Проверка:

%% ?- прост_път(g1, a, f, X).
%% X = [a, b, d, f] ;
%% X = [a, c, d, f] ;
%% X = [a, c, e, f] ;
%% false.

%% ?- прост_път(g2, a, f, X).
%% X = [a, e, f] ;
%% X = [a, b, d, e, f] ;
%% false.

% Въпреки че е кратка, дефиницията на прост_път не е ефективна, защото без
% нужда генерират всички пътища, които са по-къси от дадена дължина.  Макар
% и подходящи за контролно или изпит по ЛП, в реалния живот трябва да
% използваме други дефиниции.  По-долу виждаме един естествен опит да
% дефинираме по-ефективен вариант на прост_път.

%% прост_път2(G, V, V, [V]) :- връх(G, V).
%% прост_път2(G, U, V, [U|X]) :-
%%     ребро(G, U, W),
%%     прост_път2(G, W, V, X),
%%     not((елемент(U, X))).

% Ако проседим условието за незацикляне на горната дефиниция, ще видим, че
% тя с нищо не е по-добра от дефиницията на път.  Т.е. когато графът е
% цикличен, тя се зацикля.  Причината е в това, че условието
% not((елемент(U,X))) се появява твърде късно.  Единственият начин
% генерираните пътища да бъдат краен брой е тази проверка да бъде преди
% рекурсивното извикване, а не след него.  Но как можем да проверим дали U
% е елемент на X, ако X е неизвестно?

% Решението на проблема е да използваме помощен предикат, който има един
% допълнителен аргумент – върховете, през които не трябва да се минава.

% прост_път_извън(G, Z, U, V, X) - X е прост път в графа G от връх U до
%                                  връх V, който не минава през върховете
%                                  от Z
%
% Условие: G е краен граф, Z е известен списък

прост_път_извън(G, Z, V, V, [V]) :- връх(G, V), not(елемент(V, Z)).
прост_път_извън(G, Z, U, V, [U|X]) :-
    not(елемент(U, Z)),
    ребро(G, U, W),
    прост_път_извън(G, [U|Z], W, V, X).

% В предиката прост_път_извън условието Z да бъде известен списък може да
% бъде отслабено.  Може да искаме да бъде известно ограничение отгоре за
% дължината на Z.  За целта обаче вместо not(елемент(U, Z)) трябва да
% ползваме следния помощен предикат:

% не_елемент(U, Z) - U не е елемент на Z
%
% Условие: известно е ограничение отгоре за дължината на Z

не_елемент(_,[]).
не_елемент(A,[B|X]) :- dif(A,B), не_елемент(A,X).

% Предикатът dif казва, че аргументите са различни и може да се използва за
% променливи, чиято стойност все още не е известна.

% Имайки прост_път_извън, можем да дефинираме следната значително
% по-ефективна версия на прост_път:

прост_път2(G, U, V, X) :- прост_път_извън(G, [], U, V, X).

% Дефинициите на следващите два предиката илюстрират решаването на
% екстремални задачи на пролог.  Използваната идея не е подходяща за реално
% програмиране, но са идеални за изпита или контролното:

% разтояние(G, U, V, N) -  N е разтоянието в графа G от връх U до връх V
%
% Условие: G е краен граф

разтояние(G, U, V, N) :-
    прост_път(G, U, V, X),
    дължина(X, N+1),
    not((прост_път(G, U, V, Y),
	 дължина(Y, M+1),
	 N #> M)).

%% ?- разтояние(g1, a, d, N).
%% N = 2

%% ?- разтояние(g1, a, h, N).
%% N = 4

%% ?- разтояние(g2, a, h, N).
%% false.

%% ?- разтояние(g2, a, d, N).
%% N = 2 

% Диаметър на един граф е разтоянието между най-отдалечените върхове в
% него.

% Забележка: Диаметърът не не винаги е равен на дължината на най-дългия
% прост път в графа.  Да разледаме например графа

%    1 -----------> 2
%    ^              ^
%    |              |
%    |              |
%    |              |
%    |              |
%    |              |
%    3 <----------- 4
%
% Диаметърът на този граф е 2 (разтоянието от връх 3 до връх 2).  Въпреки
% това има път с дължина 3 (от връх 4 до връх 2).

% диаметър(G, N) - N е диаметърът на графа G
%
% Условие: G е краен граф

диаметър(G, N) :-
    разтояние(G, _, _, N),
    not(( разтояние(G, _, _, M),
	  M #> N )).

%% ?- диаметър(g1, N).
%% N = 4 

%% ?- диаметър(g2, N).
%% N = 5 

%% ?- разтояние(g2, U, V, 5).
%% U = g, V = b


% Задача. За ориентирания граф G=(V,E) тройката от множества (X,S,Y)
% наричаме сепаратор, ако удовлетворява следните четири условия:

% 1. обединението на X, S и Y е V;
% 2. никои две от множествата X, Y и S нямат общи елементи;
% 3. няма ребро от E, което свързва връх от X с връх от Y.
% 4. X и Y са непразни

% Да се дефинира предикат generate_separators(G,S,X,Y), който по граф G
% генерира в S,X,Y всички сепаратори.

% сепаратор(G, X, S, Y) - (X,S,Y) е сепаратор в графа G
%
% Условие: G е краен граф

сепаратор(G, X, S, Y) :-
    findall(W, връх(G, W), VV_),
    sort(VV_, VV),
    дължина(VV, NVV),
    дължина(Цветове, NVV),
    Цветове ins 1..3,
    label(Цветове),
    елемент(1, Цветове),
    елемент(3, Цветове),
    not(( ребро(G, U, V),
	  nth(VV, NU, U),
	  nth(Цветове, NU, 1),
	  nth(VV, NV, V),
	  nth(Цветове, NV, 3) )),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 1)), X),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 2)), S),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 3)), Y).

% Горното решение е кратко и затова е подходящо за изпит или контролно.  То
% обаче е неефективно, защото извикването на label ще генерира твърде много
% варианти за цветовете (3^N, където N е броят на върховете).  По принцип
% пролог е идеален език за решаване на на комбинаторни задачи от горния
% вид, само че извикването на label трябва да стане по-късно: едва след
% като сме казали на компютъра условието, което горе е написано в предиката
% not.  По този начин label ще генерира само варианти, които дават решение.
% И тъй като not не може да се използва за работа с променливи, чиято
% стойност все още не е известна, то вместо not трябва да използваме
% рекурсия:

сепаратор2(G, X, S, Y) :-
    findall(W, връх(G, W), VV_),
    sort(VV_, VV),
    дължина(VV, NVV),
    дължина(Цветове, NVV),
    Цветове ins 1..3,
    findall((V,W), ребро(G, V, W), EE),
    % В EE няма ребро свързващо връх с цвят 0 с връх с цвят 2
    отделени(VV, EE, Цветове),
    label(Цветове),
    елемент(1, Цветове),
    елемент(3, Цветове),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 1)), X),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 2)), S),
    findall(W, (nth(VV, NW, W), nth(Цветове, NW, 3)), Y).

% отделени(VV, EE, Цветове) - ако интерпретираме VV като списък различни
%                             върхове, Цветове като списък, с цветове на
%                             елементите на VV, EE като списък от ребра, то
%                             предикатът казва, че в EE няма ребро,
%                             свързващо връх с цвят 0 с връх с цвят 2
%
% Горното условие е еквивалентно на следното: за всеки елемент (V1,V2) на
% EE, където V1=VV[K1] и V2=VV[K2], е вярно Цветове[K1] \= 0 или
% Цветове[K2] \= 2.
%
% Условие: известно е ограничение отгоре за дължината на EE.

отделени(_, [], _).
отделени(VV, [(V1,V2)|EE], Цветове) :-
    Ц1 #\= 0 #\/ Ц2 #\= 2,
    nth(VV, K1, V1),
    nth(Цветове, K1, Ц1),
    nth(VV, K2, V2),
    nth(Цветове, K2, Ц2),
    отделени(VV, EE, Цветове).

% максимален_сепаратор(G, X, S, Y) - (X,S,Y) е такъв сепаратор в G, че няма
%                                    сепаратор с по-малко (по брой
%                                    елементи) множество S
%
% Условие:

максимален_сепаратор(G, X, S, Y) :-
    сепаратор2(G, X, S, Y),
    дължина(S, NS),
    not(( сепаратор2(G, _, S1, _),
	  дължина(S1, NS1),
	  NS1 #< NS )).


% АРИТМЕТИКА С РАЦИОНАЛНИ И ЧИСЛА И ЧИСЛА С ПЛАВАЩА ЗАПЕТАЯ

% Предикатите #=, #< и др. са предназначени само за целочислена аритметика.
% Ако искаме да смятаме с дробни числа можем да заредим библиотеката clpq
% (рационална аритметика с произволна точност) или clpr (като типа double
% на езика си).

:- use_module(library(clpq)).

% Предикатите при тези библиотеки са без #, но се ограждат в {}.  Примери:

% Решаване на просто уравнение:

%% ?- { 2*N = 3 }.
%% N = 3r2.

% Уравнение, което засега не може да се реши, просто ще бъде запомнено:

%% ?- { 2*N + 5*K= 3 }.
%% {K=3r5-2r5*N}.

% Решаване на система от уравнения:

%% ?- { 2*N + 5*K = 3, 3*N + 8*K = -5 }.
%% N = 49,
%% K = -19.

% Да дефинираме предикат, който казва, че три точки са на една права.

% права((X1,Y1), (X2,Y2), (X3,Y3)) - точките (X1,Y1), (X2,Y2) и (X3,Y3)
%                                    лежат на една права
%
% Условие: няма

права((X1,Y1), (X2,Y2), (X3,Y3)) :-
    { (X1-X3)*(Y2-Y3) = (X2-X3)*(Y1-Y3) }.


% Коя е пресечната точка на правата, минаваща през точки с координати (2,3)
% и (5,10), и правата, минаваща през точки с координати (1,5) и (-10,3)?

%% ?- права((X,Y), (2,3), (5,10)), права((X,Y), (1,5), (-10, 3)).
%% X = 214r71,
%% Y = 381r71.

% Отговор: точка с координати (214/71,381/71).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ДОПЪЛНЕНИЕ С НЕЩА, КОИТО НЕ СА ПРАВЕНИ НА УПРАЖНЕНИЯТА
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Задачата за вълк, коза и зелка.  Лодкар трябва да ги прехвърли от
% другата страна на реката.  Има лодка, но тя не може да побере всички.

% Ще разгледаме следния граф.  Нека върховете са състоянията на системата,
% т.е. кой обект къде се намира.  Но само състояния, при които вълкът не
% изяжда козата и козата не изяжда зелката.  Ребрата да показват, че е
% възможно от едно състояние можем да преминем в друго.

% Може да използваме следното конкретно представяне на върховете: четворки
% [a,b,c,d], където а-лодкар, b-вълк, c-коза, d-зелка, 0=на близкия бряг
% на реката, 1=обектът е от другата страна на реката.  Например [1,0,1,0]
% означава, че лодкарят и козата са от близката страна на реката, а вълкът
% и зелката са от другата страна.

% Да наречем този граф вкз.

% вкз_връх(X) - X е връх от графа вкз.

вкз_връх(X) :-
    X = [Лодкар, Вълк, Коза, Зелка],
    X ins 0..1,
    Лодкар #= Вълк #\/ Лодкар #= Коза,
    Лодкар #= Коза #\/ Лодкар #= Зелка.

% генератор, чрез който нещата за графи, които дефинирахме предния път,
% стават използваеми:
връх(вкз, X) :- вкз_връх(X), label(X).

% Да проверим какви върхове има в нашия граф:
%% ?- връх(вкз, X).
%% X = [0, 0, 0, 0] ;
%% X = [0, 0, 0, 1] ;
%% X = [0, 0, 1, 0] ;
%% X = [0, 1, 0, 0] ;
%% X = [0, 1, 0, 1] ;
%% X = [1, 0, 1, 0] ;
%% X = [1, 0, 1, 1] ;
%% X = [1, 1, 0, 1] ;
%% X = [1, 1, 1, 0] ;
%% X = [1, 1, 1, 1].

% В дефиницията на следващия предикат ще използваме вградения предикат
% global_cardinality, който се използва, за да намерим колко пъти в даден
% списък от цели числа се срещат различните елементи.

% Колко единици, двойки и тройки съдържа списъка [1,2,1,3,2,1]?
%% ?-  global_cardinality([1,2,1,3,2,1],[1-Na,2-Nb,3-Nc]).
%% Na = 3,
%% Nb = 2,
%% Nc = 1.

% Тук получаваме отрицателен отговор, защото имаме не само единици и двойки:
%% ?-  global_cardinality([1,2,1,3,2,1],[1-Na,2-Nb]).
%% false.

% Ценното на предиката global_cardinality е това, че може да го използваме
% за списък с все още неизвестни елементи.  (Нужно е обаче списъкът да бъде
% с вече известна дължина).

% вкз_ребро(От, До) - в графа вкз има ребро от връх Oт до връх До.
%
% Предикатът задава само ограничения
вкз_ребро(От, До) :-
    От = [Лодкар1, Вълк1, Коза1, Зелка1],
    До = [Лодкар2, Вълк2, Коза2, Зелка2],
    вкз_връх(От),
    вкз_връх(До),
    Лодкар1 #\= Лодкар2,
    Вълк1 #\= Вълк2 #==> (Вълк1#=Лодкар1 #/\ Вълк2#=Лодкар2),
    Коза1 #\= Коза2 #==> (Коза1#=Лодкар1 #/\ Коза2#=Лодкар2),
    Зелка1 #\= Зелка2 #==> (Зелка1#=Лодкар1 #/\ Зелка2#=Лодкар2),
    Вълк_преминава #<==> (Вълк1 #\= Вълк2),
    Коза_преминава #<==> (Коза1 #\= Коза2),
    Зелка_преминава #<==> (Зелка1 #\= Зелка2),
    global_cardinality([Вълк_преминава, Коза_преминава, Зелка_преминава],
		       [0-_, 1-Брой_преминаващи]),
    Брой_преминаващи #=< 1.

% генератор, чрез който нещата за графи, които дефинирахме предния път,
% стават използваеми:
ребро(вкз, От, До) :-
    вкз_ребро(От, До), append(От, До, ОтДо), label(ОтДо).

% Да проверим какви ребра излизат от началното състояние:
%% ?-  ребро(вкз,[0,0,0,0],V).
%% V = [1, 0, 1, 0] ;
%% false.
% Т.е. единственият допустим ход е лодкарят да прехвърли козата от другата
% страна на реката.

% вкз_решение(X) - в X се генерира път, който е решение на задачата
вкз_решение(X) :-
    брой_върхове(вкз, N),
    M #=< N,
    length(X, M),
    % X е път в графа, който води от [0,0,0,0] до [1,1,1,1]
    път_от_до(вкз, X, [0,0,0,0], [1,1,1,1]).

% Намиране на примерно решение
%% ?- вкз_решение(X),write(X).
%% [[0,0,0,0],[1,0,1,0],[0,0,1,0],[1,0,1,1],[0,0,0,1],[1,1,0,1],[0,1,0,1],[1,1,1,1]]
%% X = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 0, 1, 0], [1, 0, 1, 1], [0, 0, 0, 1], [1, 1, 0|...], [0, 1|...], [1|...]] 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Да разположим върху шахматната дъска 5 царици и 5 коня, така че никой не
% бие никого.

% Търсим: списък от позиции за 5 царици и списък от позиции за 5 коня

% не_бие_царица_поле((X1,Y1), (X2, Y2)) - царица, разположена в поле
%                                         (X1,Y1) не бие поле (X2,Y2).
%
% Предикатът задава само ограничения
не_бие_царица_поле((X1,Y1), (X2, Y2)) :-
    X1 #\= X2, % различен ред
    Y1 #\= Y2, % различен стълб
    X1 - X2 #\= Y1 - Y2, % различнен диагонал
    X1 - X2 #\= Y2 - Y1. % различнен диагонал

% не_бие_кон_поле((X1,Y1), (X2, Y2)) - кон, разположен в поле
%                                      (X1,Y1) не бие поле (X2,Y2).
%
% Предикатът задава само ограничения
не_бие_кон_поле((X1, Y1), (X2, Y2)) :-
    #\ (abs(X1-X2) #= 2 #/\ abs(Y1-Y2) #= 1),
    #\ (abs(X1-X2) #= 1 #/\ abs(Y1-Y2) #= 2).

% не_бие_царица_полета(Царица, Полета) - царица, разположена в поле Царица
%                                        не бие никое от полетата в
%                                        списъка Полета
%
% Условие: известно е ограничение отгоре за дължината на Полета
% Предикатът задава само ограничения
не_бие_царица_полета(_, []).
не_бие_царица_полета(Царица, [Поле|Полета]) :-
    не_бие_царица_поле(Царица, Поле),
    не_бие_царица_полета(Царица, Полета).

% не_бие_кон_полета(Кон, Полета) - кон, разположен в поле Кон не бие никое
%                                  от полетата в списъка Полета
%
% Условие: известно е ограничение отгоре за дължината на Полета
% Предикатът задава само ограничения
не_бие_кон_полета(_, []).
не_бие_кон_полета(Кон, [Поле|Полета]) :-
    не_бие_кон_поле(Кон, Поле),
    не_бие_кон_полета(Кон, Полета).

% не_бият_царици_себеси_и_полета(Царици, Полета) - цариците от списъка
%                            Царици не бият нито себе си, нито полетата от
%                            списъка Полета.
%
% Условие: известно е ограничение отгоре за дължините на Царици и Полета
% Предикатът задава само ограничения
не_бият_царици_себеси_и_полета([],_).
не_бият_царици_себеси_и_полета([Царица|Царици], Полета) :-
    не_бие_царица_полета(Царица, Царици),
    не_бие_царица_полета(Царица, Полета),
    не_бият_царици_себеси_и_полета(Царици, Полета).

% не_бият_коне_себеси_и_полета(Коне, Полета) - конета от списъка Коне не
%                      бият нито себе си, нито полетата от списъка Полета.
%
% Условие: известно е ограничение отгоре за дължините на Коне и Полета
% Предикатът задава само ограничения
не_бият_коне_себеси_и_полета([],_).
не_бият_коне_себеси_и_полета([Кон|Коне], Полета) :-
    не_бие_кон_полета(Кон, Коне),
    не_бие_кон_полета(Кон, Полета),
    не_бият_коне_себеси_и_полета(Коне, Полета).

% координати_на_полета([(A1,B1),(A2,B2),(A3,B3),(A4,B4),...],
%                      [A1,B1,A2,B2,A3,B3,A4,B4,...])
%
% Условие: известно е ограничение отгоре за дължината на поне един от
%          аргументите
координати_на_полета([],[]).
координати_на_полета([(A,B)|X],[A,B|Y]) :-
    координати_на_полета(X, Y).

% Решенията са списъци от полета.  Понеже не искаме за едно и също решение
% да намираме много пермутации, ще зададем някаква сортировка.  Като
% страничен ефект това ще ни гарантира, че всички фигури на дъската са на
% различни полета (а не например пет коня в едно шахматно квадратче).

% предхожда(Поле1,Поле2) - някаква пълна наредба между полетата на дъската
%                          (все едно каква)
%
% Предикатът задава само ограничения
предхожда((X1,Y1), (X2,Y2)) :- X1 #< X2 #\/ (X1 #= X2 #/\ Y1 #< Y2).

% сортирани_полета(X) - X е списък от полета, който е сортиран по отношение
%                       на наредбата от предиката предхожда/2.
%
% Условие: известно е ограничение отгоре за дължината на X
% Предикатът задава само ограничения
сортирани_полета([]).
сортирани_полета([_]).
сортирани_полета([A,B|X]) :-
    предхожда(A,B), сортирани_полета([B|X]).

% шах(Фигури) - генерира списък Фигури от десет шахматни полета - пет
%               царици и пет коня
шах(Фигури) :-
    не_бият_царици_себеси_и_полета([Ц1,Ц2,Ц3,Ц4,Ц5],[К1,К2,К3,К4,К5]),
    не_бият_коне_себеси_и_полета([К1,К2,К3,К4,К5],[Ц1,Ц2,Ц3,Ц4,Ц5]),
    Фигури = [Ц1,Ц2,Ц3,Ц4,Ц5,К1,К2,К3,К4,К5],
    координати_на_полета(Фигури, Координати),
    Координати ins 1..8,
    сортирани_полета([Ц1,Ц2,Ц3,Ц4,Ц5]),
    сортирани_полета([К1,К2,К3,К4,К5]),
    label(Координати).

% По-долу write(Фигури) отпечатва списъка Фигури, nl минава на нов ред, а
% предикатът fail казва на компютъра, че не сме доволни от намерения
% отговор, така че компютърът започва да генерира следващ отговор.
%% ?- шах(Фигури), write(Фигури), nl, fail.
%% [(1,2),(2,7),(3,3),(4,6),(5,8),(6,1),(7,1),(7,4),(7,5),(8,4)]
%% [(1,3),(2,6),(3,2),(4,7),(6,1),(7,5),(7,8),(8,4),(8,5),(8,8)]
%% [(1,3),(2,6),(3,8),(6,7),(7,5),(4,1),(5,1),(5,2),(8,1),(8,2)]
%% [(1,4),(2,7),(3,5),(6,6),(7,8),(4,2),(5,1),(5,2),(8,2),(8,3)]
%% [(1,5),(2,2),(3,4),(6,3),(7,1),(4,7),(5,7),(5,8),(8,6),(8,7)]
%% [(1,6),(2,3),(3,1),(6,2),(7,4),(4,8),(5,7),(5,8),(8,7),(8,8)]
%% [(1,6),(2,3),(3,7),(4,2),(6,8),(7,1),(7,4),(8,1),(8,4),(8,5)]
%% [(1,7),(2,2),(3,6),(4,3),(5,1),(6,8),(7,4),(7,5),(7,8),(8,5)]
%% [(2,1),(3,3),(6,4),(7,2),(8,5),(1,6),(1,7),(4,7),(4,8),(5,7)]
%% [(2,4),(3,2),(6,1),(7,3),(8,6),(1,7),(1,8),(4,7),(4,8),(5,8)]
%% [(2,5),(3,7),(6,8),(7,6),(8,3),(1,1),(1,2),(4,1),(4,2),(5,1)]
%% [(2,8),(3,6),(6,5),(7,7),(8,4),(1,2),(1,3),(4,1),(4,2),(5,2)]
%% [(3,1),(5,7),(6,2),(7,6),(8,3),(1,4),(1,5),(1,8),(2,5),(2,8)]
%% [(3,8),(5,2),(6,7),(7,3),(8,6),(1,1),(1,4),(1,5),(2,1),(2,4)]
%% [(4,1),(5,3),(6,6),(7,2),(8,7),(1,5),(2,4),(2,5),(2,8),(3,8)]
%% [(4,8),(5,6),(6,3),(7,7),(8,2),(1,4),(2,1),(2,4),(2,5),(3,1)]
%% false.

% Ето как изглежда първото от намерените решения:

%   ...К....
%   K..KK...
%   K.......
%   .......Ц
%   .....Ц..
%   ..Ц.....
%   ......Ц.
%   .Ц......

% Всъщност от всяко решение с помощта на ротация и обръщане на дъската
% получаваме общо осем еквивалентни на него решения.  По-горе получихме
% общо 16 отговора, следователно има само две решения, които не са
% еквивалентни с точност до някаква симетрия.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Разглеждаме дървета, които ще представяме с термове от следните два вида:

% leaf(A) - дървото е единствен лист с етикет A
% node(T1,T2) - от връх излизат две поддървета T1 и T2

% Примерно дърво: node(leaf(a),node(leaf(b),leaf(c)))

%                      .
%                     / \
%                    /   \
%                   a     .
%                        / \
%                       /   \
%                      b     c

% Да направим предикати, които по дърво намират списък от етикетите в
% листата му и по списък от листа намират дърво с тези листа.

% tree_leafs(T, X) - X е списък от листата на дървото T
%
% Условие: Известно е ограничение отгоре за размера на T.
tree_leafs(leaf(A), [A]).
tree_leafs(node(T1,T2), X) :-
    tree_leafs(T1, X1),
    tree_leafs(T2, X2),
    append(X1, X2, X).

% Кои са етикетите в листата на дървото node(leaf(a),node(leaf(b),leaf(c)))
%% ?- tree_leafs(node(leaf(a),node(leaf(b),leaf(c))), X).
%% X = [a, b, c].

% От математическа гледна точка по-долният предикат е еквивалентен на
% горния.  Условието обаче е друго.  С горния предикат от дърво правим
% списък листа, а с долния – от списък листа правим дърво.

% leafs_tree(X, T) - X е списък от листата на дървото T
%
% Условие: известно е ограничение отгоре за дължината на X
leafs_tree([A], leaf(A)).
leafs_tree(X, node(T1,T2)) :-
    X1 = [_|_], X2 = [_|_],
    append(X1, X2, X),
    leafs_tree(X1, T1),
    leafs_tree(X2, T2).

% Кои са дърветата, които в листата си имат етикети [a,b,c]?
%% ?- leafs_tree([a,b,c],T).
%% T = node(leaf(a), node(leaf(b), leaf(c))) ;
%% T = node(node(leaf(a), leaf(b)), leaf(c)) ;
%% false.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 1 от 15 юни 2016
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% подмножество(X, Y) - X е подмножество на Y, т.е. може да се получи като
%                      „задраскаме“ някои елементи на Y
%
% Условие: известно е ограничение отгоре за дължината на Y

подмножество([], []).
подмножество([A|X], [A|Y]) :- подмножество(X, Y).
подмножество(X, [_|Y]) :- подмножество(X, Y).

% p20160615a(L) - по даден списък L от списъци проверява дали за всеки два
% елемента на L съществува трети елемент, съдържащ общите елементи на
% другите два.

p20160615a(L) :-
    forall(подмножество([X,Y], L),
           (member(Z, L), forall((member(A, X), member(A, Y)),
                                 member(A, Z)))).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 1 от 3 септември 2016
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% делител(N, X) - N е делител на елементите на X
%
% Условие: X е списък с известни елементи

делител(N, X) :-
    once(member(B, X)), N * _L #= B, label([N]),
    forall(member(A,X), N * _K #= A).

% нод(N, X) - N е най-големият общ делител на елементите на X
%
% Условие: X е списък с известни елементи

нод(N, X) :-
    делител(N, X),
    forall(делител(M, X), M #=< N).

% p20160903a(L, N) - по списък от естествени числа L и естествено число N
% проверява дали има N елемента a[1]..a[N] на L, чийто НОД се различава от
% НОД на кои да е N-1 елемента b[1]..b[N-1] на L.

p20160903a(L, N) :-
    дължина(AA, N), подмножество(AA, L),
    нод(Нод_AA, AA),
    forall((дължина(BB, N-1), подмножество(BB, L)),
           (Нод_BB #\= Нод_AA, нод(Нод_BB, BB))).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 2 от 3 септември 2016
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% А се поглъща от B (списъци от числа), ако сборът на всеки два елемента на
% A се съдържа в B.

поглъща_се_от(X, Y) :-
    forall(подмнож([A,B], X),
           (N #= A + B, member(N, Y))).

всеки_се_поглъща_от_следващи(X) :-
    forall(append(_, [A|Y], X),
           forall(member(B, Y),
                  поглъща_се_от(A, B))).

% Два начина да изтълкуваме условието на задачата: различни елементи на
% списък в смисъл на различни по позиция или различни по стойност.

% Различни по позиция:

%% q(L, S) :-
%%     подмнож(X, L), пермутация(X, S), ......

% Различни по стойност:

% Не става така:
% подмнож([A|Y]   , [A|X]) :- подмнож(Y, X).

% подмнож_разлика(X, Y, Z) -
%              Z списък от различни елементи на разликата X\Y
%
% Условие: списъците X и Y са известни

подмнож_разлика(_,_,[]).
подмнож_разлика(X, Y, [A|Z]) :-
        member(A, X), not(member(A, Y)), % A in X\Y
        подмнож_разлика(X, [A|Y], Z).

% подмнож(X, Y) - X е списък от различни елементи на Y
%
% Условие: списъкът Y е известен

подмнож(X, Y) :- подмнож_разлика(Y, [], X).

% q20160903b(L,S) - по даден списък L от списъци от
% числа генерира в S максимална (по дължина) редица от
% различни елементи на L, в която всеки елемент се
% поглъща от всички следващи елементи на S.

q20160903b(L, S) :-
    подмнож(S, L), всеки_се_поглъща_от_следващи(S),
    forall((подмнож(S1, L),
	    всеки_се_поглъща_от_следващи(S1)),
           (дължина(S, LenS), дължина(S1, LenS1),
	    LenS1 #=< LenS)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 1 от 21 ноември 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% а0=1, an=2a[n-1]+n, b0=1, bn=3b[n-1]+n² - 1.

a(N,A) :-
    N #= 0, A #= 1
    ;
    N #> 0, A #= 2*A1+N, a(N-1,A1).

b(N,B) :-
    N #= 0, B #= 1
    ;
    N #> 0, B #= 3*B1+N*N-1, b(N-1,B1).

% p20151121a(N) - генерира числата от вида ai+bj.

% безкраен_генератор(N) :-
%       nat(K),
%       краен_генератор(K, N).

p20151121a(N) :-
    nat(K),
    0 #=< I, 0 #=< J, I #< K, J #< K,
    N #= AI + BJ, a(I, AI), b(J, BJ),
    label([N]).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 1 от 16 април 2016
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% монотонни_префикси(X) - X е списък от списъци,
%                         всеки от които е префикс на следващия
%
% Условие: известно е ограничение отгоре за дължината на X,
%          както и за дължината на елементите на X

монотонни_префикси([]).
монотонни_префикси([_]).
монотонни_префикси([A,B|X]) :-
    append(A,_,B), % А е префикс на B
    монотонни_префикси([B|X]).

% p20160416a(L) - генерира всички списъци от списъци от
% естествени числа между 0 и 99, такива че всеки елемент
% е префикс на следващия.

% Псевдокод:

%% p20160416a(L) :-
%%     nat(K),
%%     N #=< K, дължина(L, N), елементите на L са с дължина =<K,
%%     елементите на елементите на L са между 0 и 99,
%%     монотонни_префикси(L).

% къс_от_къси_от_0_99(N, M, X) -
%           X е списък от не повече от N елемента,
%           всеки от които е списък с не повече от M елемента,
%           всеки от които е число между 0 и 99
% По дадени N и M се генерират стойности за X

къс_от_къси_от_0_99(N, M, X) :-
    LenX #=< N, дължина(X, LenX),
    ( X = []
    ; X = [A|Y],
      LenA #=< M, дължина(A, LenA), A ins 0..99,
      къс_от_къси_от_0_99(N-1, M, Y)).

% По-горе вместо A ins 0..99 може да използваме ins099(A)

ins099([]).
ins099([A|X]) :- 0 #=< A, A #=< 99, ins099(X).

p20160416a(L) :-
    nat(K),
    къс_от_къси_от_0_99(K, K, L), монотонни_префикси(L),
    append(_,[Последен], L), label(Последен).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Задача 2 от 16 април 2016
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Граф G представяме чрез списък от ребра.
% p20160416b(G) - графът G има оцветяване в два цвята
%                 без едноцветни триъгълници

% Оцветен граф: терм X*Y, където:
%    X е списък от двойки (V, C), където V е връх,
%                                 а C цвят на този връх
%    Y е списък от ребра (U, V)

връх(X*_, V) :- member((V,_), X).
ребро(_*Y, U, V) :- member((U,V), Y).

% цвят(G, V, C) - връх V на оцветен граф G има цвят C

цвят(X*_, V, C) :- member((V,C), X).

% Искаме да може да получаваме списъци от всички цветове.

% При върховете и ребрата използвахме такава дефиниция:

% върхове(G, Върхове) :- findall(V, връх(G, V), Върхове).
% ребра(G, Ребра) :- findall((U,V), ребро(G, U, V), Ребра).

% Но при цветовете не може да използваме findall, защото все още не са
% известни.

% сдвояване(X, Y, Z) :-
%       N-тият елемент на Z е двойка (A,B), където
%       A е N-тият елемент на X, B е N-тият елемент на Y
%
% Условие: известно е ограничение отгоре на дължината
%          на поне един от списъците X, Y или Z

сдвояване([],[],[]).
сдвояване([A|X], [B|Y], [(A,B)|Z]) :- сдвояване(X,Y,Z).

цветове(X*_, Цветове) :- сдвояване(_, Цветове, X).

% прави_оцветен(G, Colored) - Colored е оцветен граф,
%                             имащ същите върхове и ребра като G
%
% Условие: G е с известни върхове и ребра

% Иска ни се да дефинираме предиката прави_оцветен/2 кратко по следния
% начин:

% прави_оцветен(G, X*Y) :-
%     върхове(G, Върхове), сдвояване(Върхове, _, X), ребра(G, Y).

% Това обаче не е правилно, защото предикатът върхове не гарантира, че ще
% получаваме списък от различни върхове.  Затова ако някой връх се среща
% повече от веднъж в списъка Върхове, то той ще се среща повече от веднъж в
% X, което ще даде възможност един и същи връх да има повече от един цвят.
% За да не се случва това, трябва да махнем „дубликатите“ от Върхове:

прави_оцветен(G, X*Y) :-
    върхове(G, СписъкВърхове),
    sort(СписъкВърхове, МножествоВърхове),
    сдвояване(МножествоВърхове, _, X),
    ребра(G, Y).

разноцветни(G, A, B, C) :-
    цвят(G, A, Цвят_A), цвят(G, B, Цвят_B), цвят(G, C, Цвят_C),
    min(min(Цвят_A, Цвят_B), Цвят_C) #< max(max(Цвят_A,Цвят_B),Цвят_C).

% Ако последният ред по-горе заменим със следващия,
% получаваме комбинаторен взрив:
% Цвят_А #\= Цвят_B ; Цвят_A #\= Цвят_C ; Цвят_B #\= Цвят_C

% Но така може:
% Цвят_А #\= Цвят_B #\/ Цвят_A #\= Цвят_C #\/ Цвят_B #\= Цвят_C

% триъгълник(G, A, B, C) - в графа G има път A => B => C => A

триъгълник(G, A, B, C) :-
    връх(G, A), ребро(G, A, B), ребро(G, B, C), ребро(G, C, A).

% триъгълници(G, X) - X е списък от всички тройки (A,B,C), такива че
%                     в графа G има път A => B => C => A

триъгълници(G, X) :- findall((A,B,C), триъгълник(G,A,B,C), X).

% всички_разноцветни(G, X) - всички елементи (A,B,C) на X са разноцветни

всички_разноцветни(_, []).
всички_разноцветни(G, [[A,B,C]|X]) :-
    разноцветни(G, A, B, C), всички_разноцветни(G, X).

p20160416b(G) :-
    прави_оцветен(G, Colored),
    цветове(Colored, Цветове), Цветове ins 0..1,
    триъгълници(Colored, X),
    всички_разноцветни(Colored, X),
    label(Цветове).
